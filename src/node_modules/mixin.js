import isArray from 'lodash/isArray'
import isFunction from 'lodash/isFunction'

// ===================================================================

const { defineProperties } = Object.prototype
const { getOwnPropertyDescriptor } = Object

const bind = (fn, thisArg) => function _bound_ () {
  return fn.apply(thisArg, arguments)
}

const bindPropertyDescriptor = (descriptor, thisArg) => {
  const { get, set, value } = descriptor
  if (get) {
    descriptor.get = bind(get, thisArg)
  }
  if (set) {
    descriptor.set = bind(set, thisArg)
  }

  if (isFunction(value)) {
    descriptor.value = bind(value, thisArg)
  }

  return descriptor
}

const isIgnoredProperty = name => (
  name[0] === '_' ||
  name === 'constructor'
)

const IGNORED_STATIC_PROPERTIES = {
  __proto__: null,

  arguments: true,
  caller: true,
  length: true,
  name: true,
  prototype: true
}
const isIgnoredStaticProperty = name => IGNORED_STATIC_PROPERTIES[name]

const ownKeys = (
  typeof Reflect !== 'undefined' && Reflect.ownKeys ||
  (({
    getOwnPropertyNames: names,
    getOwnPropertySymbols: symbols
  }) => symbols
    ? obj => names(obj).concat(symbols(obj))
    : names
  )(Object)
)

// -------------------------------------------------------------------

export { mixin as default }
const mixin = Mixins => Class => {
  if (process.env.NODE_ENV !== 'production' && !isArray(Mixins)) {
    throw new TypeError('Mixins should be an array')
  }

  const { name } = Class

  // Copy properties of plain object mix-ins to the prototype.
  {
    const allMixins = Mixins
    Mixins = []
    const { prototype } = Class
    const descriptors = { __proto__: null }
    for (const Mixin of allMixins) {
      if (isFunction(Mixin)) {
        Mixins.push(Mixin)
        continue
      }

      for (const prop of ownKeys(Mixin)) {
        if (prop in prototype) {
          throw new Error(`${name}#${prop} is already defined`)
        }

        (
          descriptors[prop] = getOwnPropertyDescriptor(Mixin, prop)
        ).enumerable = false // Object methods are enumerable but class methods are not.
      }
    }
    defineProperties(prototype, descriptors)
  }

  const Decorator = (...args) => {
    const instance = new Class(...args)

    for (const Mixin of Mixins) {
      const { prototype } = Mixin
      const mixinInstance = new Mixin(instance, ...args)
      const descriptors = { __proto__: null }
      for (const prop of ownKeys(prototype)) {
        if (isIgnoredProperty(prop)) {
          continue
        }

        if (prop in instance) {
          throw new Error(`${name}#${prop} is already defined`)
        }

        descriptors[prop] = bindPropertyDescriptor(
          getOwnPropertyDescriptor(prototype, prop),
          mixinInstance
        )
      }
      defineProperties(instance, descriptors)
    }

    return instance
  }

  // Copy original and mixed-in static properties on Decorator class.
  const descriptors = { __proto__: null }
  for (const prop of ownKeys(Class)) {
    let descriptor
    if (!(
      // Special properties are not defined...
      isIgnoredStaticProperty(prop) &&

      // if they already exist...
      (descriptor = getOwnPropertyDescriptor(Decorator, prop)) &&

      // and are not configurable.
      !descriptor.configurable
    )) {
      descriptors[prop] = getOwnPropertyDescriptor(Class, prop)
    }
  }
  for (const Mixin of Mixins) {
    for (const prop of ownKeys(Mixin)) {
      if (isIgnoredStaticProperty(prop)) {
        continue
      }

      if (prop in descriptors) {
        throw new Error(`${name}.${prop} is already defined`)
      }

      descriptors[prop] = getOwnPropertyDescriptor(Mixin, prop)
    }
  }
  defineProperties(Decorator, descriptors)

  return Decorator
}
