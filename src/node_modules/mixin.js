import { forEach, isArray, isFunction, keys } from 'lodash'
import { getBoundPropertyDescriptor } from 'bind-property-descriptor'

// ===================================================================

const __DEV__ = process.env.NODE_ENV !== 'production'

// ===================================================================

const { defineProperties, getOwnPropertyDescriptor } = Object

const isIgnoredProperty = name => (
  name[0] === '_' ||
  name === 'constructor'
)

const IGNORED_STATIC_PROPERTIES = {
  __proto__: null,

  arguments: true,
  caller: true,
  length: true,
  name: true,
  prototype: true
}
const isIgnoredStaticProperty = name => IGNORED_STATIC_PROPERTIES[name]

// -------------------------------------------------------------------

const mixin = Mixins => Class => {
  if (__DEV__ && !isArray(Mixins)) {
    throw new TypeError('Mixins should be an array')
  }

  const { name } = Class

  // Copy properties of plain object mix-ins to the prototype.
  {
    const allMixins = Mixins
    Mixins = []
    const { prototype } = Class
    const descriptors = { __proto__: null }
    forEach(allMixins, Mixin => {
      if (isFunction(Mixin)) {
        Mixins.push(Mixin)
        return
      }

      for (const prop of keys(Mixin)) {
        if (__DEV__ && prop in prototype) {
          throw new Error(`${name}#${prop} is already defined`)
        }

        (
          descriptors[prop] = getOwnPropertyDescriptor(Mixin, prop)
        ).enumerable = false // Object methods are enumerable but class methods are not.
      }
    })
    defineProperties(prototype, descriptors)
  }

  const n = Mixins.length

  function DecoratedClass (...args) {
    const instance = new Class(...args)

    for (let i = 0; i < n; ++i) {
      const Mixin = Mixins[i]
      const { prototype } = Mixin
      const mixinInstance = new Mixin(instance, ...args)
      const descriptors = { __proto__: null }
      const props = keys(prototype)
      for (let j = 0, m = props.length; i < m; ++i) {
        const prop = props[j]

        if (isIgnoredProperty(prop)) {
          continue
        }

        if (prop in instance) {
          throw new Error(`${name}#${prop} is already defined`)
        }

        descriptors[prop] = getBoundPropertyDescriptor(prototype, prop, mixinInstance)
      }
      defineProperties(instance, descriptors)
    }

    return instance
  }

  // Copy original and mixed-in static properties on Decorator class.
  const descriptors = { __proto__: null }
  forEach(keys(Class), prop => {
    let descriptor
    if (!(
      // Special properties are not defined...
      isIgnoredStaticProperty(prop) &&

      // if they already exist...
      (descriptor = getOwnPropertyDescriptor(DecoratedClass, prop)) &&

      // and are not configurable.
      !descriptor.configurable
    )) {
      descriptors[prop] = getOwnPropertyDescriptor(Class, prop)
    }
  })
  forEach(Mixins, Mixin => {
    forEach(keys(Mixin), prop => {
      if (isIgnoredStaticProperty(prop)) {
        return
      }

      if (__DEV__ && prop in descriptors) {
        throw new Error(`${name}.${prop} is already defined`)
      }

      descriptors[prop] = getOwnPropertyDescriptor(Mixin, prop)
    })
  })
  defineProperties(DecoratedClass, descriptors)

  return DecoratedClass
}
export { mixin as default }
